<!doctype html>
<html lang="en">

  <head>
    <meta charset="utf-8">

    <title>Image Denoising</title>

    <meta name="description" content="A framework for easily creating beautiful presentations using HTML">
    <meta name="author" content="Hakim El Hattab">

    <meta name="apple-mobile-web-app-capable" content="yes" />
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent" />

    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no, minimal-ui">

    <link rel="stylesheet" href="css/reveal.css">
    <link rel="stylesheet" href="css/theme/black.css" id="theme">

    <!-- Code syntax highlighting -->
    <link rel="stylesheet" href="lib/css/zenburn.css">
    <link rel="stylesheet" href="https://maxcdn.bootstrapcdn.com/font-awesome/4.4.0/css/font-awesome.min.css">

    <!-- Printing and PDF exports -->
    <script>
      var link = document.createElement( 'link' );
      link.rel = 'stylesheet';
      link.type = 'text/css';
      link.href = window.location.search.match( /print-pdf/gi ) ? 'css/print/pdf.css' : 'css/print/paper.css';
      document.getElementsByTagName( 'head' )[0].appendChild( link );
    </script>

    <!--[if lt IE 9]>
    <script src="lib/js/html5shiv.js"></script>
    <![endif]-->

    <!-- my customized style -->
    <style>
    .reveal h1, .reveal h2, .reveal h3, .reveal h4, .reveal h5, .reveal h6 {
      color: #FFEBCD;
    }
    </style>
  </head>

  <body>

    <div class="reveal">

      <!-- Any section element inside of this container is displayed as a slide -->
      <div class="slides">
        <section id="title">
          <h1>A non-local algorithm for image denoising</h1>
          <p>
            CMPT 469 Presentation @Hongyi Zhang
          </p>
          <p>
            October 15, 2015
          </p>
        </section>      

        <section id="introduction">
          <section>
            <h2>Image Noises</h2>
            <p class="fragment">
              Noises could be generated.
            </p>
            <span class="fragment">
              <img width="400" height="400" src="data/lena_noise.png" alt="noise example 1" >
            </span>
            <span class="fragment">
              <pre><code data-trim contenteditable>
                imnoise(I, 'gaussian'); % generated by Matlab
              </code></pre>
            </span>
          </section>
         
          <section>
            <p>
              It's not uncommon to discover noises in natural images.
            </p>
            <table>
              <tbody>
                <tr>
                  <td>
                    <img width="350" height="350" src="data/sky_noise.jpg" alt="noise example 2" >
                  </td>
                  <td>
                    <img width="350" height="350" src="data/jellyfish.jpg" alt="noise example 3" >
                  </td>
                </tr>
                <tr>
                  <td><small>SFU Diamond Alumni Center</small></td>
                  <td><small>Cute Jellyfish and their Excreta</small></td>
                </tr>       
              </tbody>
            </table>
          </section>

          <section>
            <p>
              Recall Image Formation: images noises and ISO
            </p>
            <p>
              <small>We have learned in class that higher ISO will result in more noises.</small>
            </p>
            <img width="600" height="400" src="data/iso-sensitivity-comparison.jpg" alt="noise and ISO" >
            <p>
              <small>Image from <a href="http://www.exposureguide.com/iso-sensitivity.htm">http://www.exposureguide.com/iso-sensitivity.htm</a></small>
            </p>
          </section>
        </section>

        <section id='goal'>
          <h2>The purpose of this Paper</h2>
          <ol>
              <li>Propose a new measurement, <em><a href="#/3">Method Noise</a></em>, to compare different denoising methods</li>
              <li>Propose a new denoising algorithm, <em><a href="#/5">Non-Local Mean</a></em>, based on non-local averaging</li>
          </ol>
        </section>

        <section id="method noise">
          <section>
            <h2>Method Noise</h2>
            <p>Method noise is defined as the image difference. Let u be an image and Dh a denoising operator depending on a filtering parameter h.</p>
            <pre><code data-trim contenteditable>
              Method Noise = u(original image) - Dh*u(processed image)
            </code></pre>
          </section>

          <section>
            <h3>Visualization of Method Noise</h3>
            <p class="fragment">A good denoising method should have method noise containing as little structures as possible.</p>
            <figure style="display: inline-block; position: absolute; left: 0%">
              <img src="data/lena_gauss_0.05.png" alt="noisy lena" width="256" height="256">
              <figcaption><small>Original noisy image</small></figcaption>
            </figure>

            <div style="display: inline-block; position: absolute; left: 30%; padding-top:13%">
              <i class="fa fa-minus"></i>
            </div>
            <figure style="display: inline-block; position: absolute; left:35%">
              <img src="data/lena.png" alt="original lena" width="256" height="256">
            <figcaption><small>Processed image</small></figcaption>
            </figure>
            <span style="display: inline-block; position: absolute; left: 65%; padding-top:13%">
            <i class="fa fa-arrow-right"></i></span>

            <figure style="display: inline-block; position: absolute; right:0%">
              <img src="data/method_noise.png" alt="method noise" width="256" height="256">
              <figcaption><small>Method Noise</small></figcaption>
            </figure>
          </section>
        </section>

        <section id="review">
          <section>
            <h2>Classic Local Smoothing Methods</h2>
            <ul class="fragment">
              <li><a href='#/4/1'>The Gaussian filtering</a></li>
              <li><a href='#/4/6'>The neighborhood filtering</a></li>
              <li><a href='#/4/9'>The anisotropic filtering</a></li>
              <li><a href='#/4/11'>The Total Variation minimization</a></li>
            </ul>
          </section>
          <section>
            <h3>1. Gaussian Filter</h3>
            <img src="data/gauss_19_3.png" >
            <p>Intuition: reduce noise by averaging nearby pixels and weights are decided by distance.</p>
          </section>
          <section>
            <h3>Try Gaussian</h3>
            <img src="data/lena_noise2.png" >
          </section>
          <section>
            <h3>Try Gaussian</h3>
            <img src="data/gauss_denoise.png" >
          </section>
          <section>
            <h3>Method Noise of Gaussian</h3>
            <img src="data/gauss_noise.png" >
            <p>By design, Gaussian filter is optimal in flat part, but edges are not preserved.</p>
          </section>
          <section>
            <p>Any better idea to preserve edges?</p>
          </section>
          <section>
            <h3>2. The neighborhood filtering</h3>
            <ul>
              <li>Assumption: edges must have different intensities.</li>
              <li>Instead of taking average of all nearby pixels, we only consider nearby pixels with similar greyscale intensities.</li>
              <li>Does this idea sound familiar?...We already learned one of the neighborhood filtering. <em>The Bilateral filter!</em></li>
            </ul>
          </section>
          <section>
            <h3>Bilateral filter</h3>
            <p>It can be implemented with two Gaussian kernels</p>
            <ul>
              <li>First Gaussian for weights of distance.</li>
              <li>Second Gaussian for weights of pixel values.</li>
            </ul>
            <img src="data/bilateral_filter.png" >
            <p><small>Reference: CMPT 469 course material post processing slides<br>Image from <a href="http://homepages.inf.ed.ac.uk/rbf/CVonline/LOCAL_COPIES/MANDUCHI1/Bilateral_Filtering.html">Bilateral Filtering for Gray and Color Images</a></small></p>  
          </section>
          <section>
            <h3>Limitations of the neighborhood filtering</h3>
            <p>So far, neighborhood filter looks like a promising way to solve the problem. However, is it really convincing to only compare grayscale intensities?</p>
            <p>Relying on grayscale intensities in not robust if these values are noisy...</p>
          </section>
          <section>
            <h3>3. The anisotropic filtering(AF)</h3>
            <ul>
              <li>AF does not perform same filtering in every direction.</li>
              <li>first proposed by Perona and Malik(1990), now widely used to in 3D computer graphics to enhance textures</li>
            </ul>
          </section>
          <section>
            <h3>A simple example of AF</h3>
            <ul>
              <li>Edge detection by image gradient: diffuse one pixel only along the direction orthogonal to the direction of its gradient.</li>
              <li>Use 1D Gaussian as kernel</li>
              <li>Also space variant!</li>
            </ul>
            <img src="data/gradient.png">
            <p>We could imagine that the result would be opposite to the isotropic Gaussian filtering. AF performs well on edges, while causing troubles to flat areas.</p>
          </section>
          <section>
            <h3>4. The Total Variation minimization(TV)</h3>
            <ul>
              <li>Introduced by Rudin, Osher and Fatemi.</li>
              <li>Variance: the difference of values between adjacent pixels</li>
              <li>Assumption: original image should be smooth, thus the total variance should be minimized.</li>
            </ul>
            <img src="data/total_var.png">
            <p><small>
              u: result image<br>
              v: noisy image<br>
              lambda: scalar, adjusting the degree of smoothness
            </small></p>
            <p>Recall seamless cloning. They are both minimization problems and the process of calculation is similar.</p>
          </section>
          <section>
            <h3>Result of TV</h3>
            <p>Edges are maintained, but adjusting lambda could be a problem. If lambda is too small here, flat areas could over-smoothed.</p>
            <img src="https://upload.wikimedia.org/wikipedia/en/e/e8/ROF_Denoising_Example.png">
          </section>
          <section>
            <p>Are classic methods good enough?</p>
            <ul>
              <li>Probably no...</li>
              <li>They are more or less smoothing methods, trying to separate the noises rather than correct them.</li>
              <li>Only neighbors are considered.</li>
            </ul>
          </section>
        </section>

        <section>
            <section>
              <h2>New Method: Non-Local means method</h2>
              <ul>
                <li>Basic idea: for one single pixel i, the new estimated value is a weighted average of all pixels in the image.</li>
                <li>If the pixel is more similar to pixel i, it has a higher weight. The total weight is 1.</li>
                <li>Q: How do we define similarities?</li>
              </ul>
            </section>
            <section>
                <h2>Similarity</h2>
                <p>The answer is the neighbors!</p>
                <p><small>For two neighbors, the similarity between them is defined as the Euclidean distance convoled with a Gaussian kernel. The final weights need to be normalized.</small></p>
                <img witdth="500" height="500" src="data/lena_similarity.png" >
            </section>
            <section>
              <h2>Similarity</h2>
              <img src="data/result1.png" >
              <p>Those pixels has entirely different neighbor structures tend to have zero weight.</p>
              <p><a href="http://bengal.missouri.edu/~kes25c/nl2.pdf">Buades et al. 2005</a></p>
            </section>
            <section>
              <h5>Does this method sound familar?</h5>
              <p>Almost the same as texture synthesis! They share the same way to pick candidate pixels(calculate neighbor distances).</p>
              <ul>Some minor differences
                <li>Texture synthesis wants to generate a new image, while the goal of NL-mean denoising is to correct itself.</li>
                <li>Texture synthesis is in favor of randomness so it picks a random cadidate. NL-mean acts the opposite. It takes the average to eliminrate randomness.</li>
              </ul>
              <p>But again, the idea behind them is exactly the same.</p>
            </section>
        </section>

        <section>
          <section>
            <h2>Result Comparison</h2>
          </section>
          <section>
            <h3>Method Noise</h3>
            <img witdth="600" height="400" src="data/result2.png" >
            <p><small>1. Original image 2. Gaussian Filtering 3. Anisotropic filtering<br>
            4. Total variation minimization 5. Neighborhood filtering 6. NL-means algorithm</small></p>
          </section>
          <section>
            <h3>Denoised Images</h3>
            <img witdth="600" height="400" src="data/result3.png" >
            <p><small>1. Original image 2. Gaussian Filtering 3. Anisotropic filtering<br>
            4. Total variation minimization 5. Neighborhood filtering 6. NL-means algorithm</small></p>
          </section>  
          <section>
            <h3>Analysis</h3>
            <p>By nature, NL-mean method serves better on texture-like images. But we can see that it still generates satisfying results of natural images due to natural redundancies.</p>
          </section>  
          <section>
            <h3>Analysis</h3>
            <p>The disadvantage of this method is its high computational complexity. In practice, the search of similar pixels is restricted to a relatively large window size. 21*21 window size is applied in the above examples.</p>
          </section>  
        </section>

        <section style="text-align: left;">
          <h1>The end</h1>
          <h2>Thank you!</h2>
          <p>
            - Reference: <a href="http://bengal.missouri.edu/~kes25c/nl2.pdf">A non-local algorithm for image denoising</a> <br>
            - Slides built by <a href="https://github.com/hakimel/reveal.js">Reveal.js</a>
          </p>
        </section>

      </div>

  </div>

  <script src="lib/js/head.min.js"></script>
  <script src="js/reveal.js"></script>

  <script>
    // Full list of configuration options available at:
    // https://github.com/hakimel/reveal.js#configuration
    Reveal.initialize({
      controls: true,
      progress: true,
      history: true,
      center: true,

      transition: 'none', // none/fade/slide/convex/concave/zoom

      // Optional reveal.js plugins
      dependencies: [
        { src: 'lib/js/classList.js', condition: function() { return !document.body.classList; } },
        { src: 'plugin/markdown/marked.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/markdown/markdown.js', condition: function() { return !!document.querySelector( '[data-markdown]' ); } },
        { src: 'plugin/highlight/highlight.js', async: true, condition: function() { return !!document.querySelector( 'pre code' ); }, callback: function() { hljs.initHighlightingOnLoad(); } },
        { src: 'plugin/zoom-js/zoom.js', async: true },
        { src: 'plugin/notes/notes.js', async: true }
      ]
    });
  </script>

  </body>
</html>
